{
  "code_quality_factors": {
    "architecture_and_design": {
      "separation_of_concerns": {
        "description": "Does each module/class have a single reason to change?",
        "principle": "Single Responsibility Principle (SOLID)",
        "evaluation": "Rate adherence to SRP and identify violations"
      },
      "coupling": {
        "description": "How interdependent are the components?",
        "evaluation": "Assess tight vs. loose coupling, identify problematic dependencies"
      },
      "cohesion": {
        "description": "Are related functions logically grouped together?",
        "evaluation": "Check if modules have high cohesion and clear boundaries"
      },
      "design_scalability": {
        "description": "Can the system grow without massive refactoring?",
        "evaluation": "Identify architectural bottlenecks and extensibility issues"
      }
    },
    "code_quality": {
      "readability": {
        "description": "Descriptive names, clear logic, low cyclomatic complexity",
        "evaluation": "Measure complexity metrics, naming consistency, code clarity"
      },
      "dry_principle": {
        "description": "Is there unnecessary code duplication?",
        "principle": "Don't Repeat Yourself",
        "evaluation": "Identify duplicated logic, magic numbers, repeated patterns"
      },
      "function_size": {
        "description": "Are functions small and focused on doing one thing well?",
        "evaluation": "Check function length and complexity"
      },
      "error_handling": {
        "description": "Is it consistent and appropriate?",
        "evaluation": "Review exception handling, edge cases, failure scenarios"
      }
    },
    "testing": {
      "coverage": {
        "description": "What percentage of code is tested?",
        "evaluation": "Measure test coverage and identify untested critical paths"
      },
      "test_types": {
        "description": "Unit, integration, and e2e tests",
        "evaluation": "Assess test pyramid balance and appropriate test levels"
      },
      "test_quality": {
        "description": "Are tests maintainable and testing real behavior?",
        "evaluation": "Check for brittle tests, proper assertions, test independence"
      }
    },
    "documentation": {
      "readme": {
        "description": "Clear setup, purpose, general architecture",
        "evaluation": "Assess completeness and clarity of onboarding docs"
      },
      "self_documenting_code": {
        "description": "Does the code explain its intent?",
        "evaluation": "Check if code structure and naming reduce comment needs"
      },
      "comments": {
        "description": "Only where they add value (the 'why', not the 'what')",
        "evaluation": "Review comment quality and necessity"
      },
      "diagrams": {
        "description": "For complex architectures",
        "evaluation": "Check for architecture diagrams, flow charts where needed"
      }
    },
    "repository_management": {
      "commit_history": {
        "description": "Clear messages, atomic commits",
        "evaluation": "Review commit message quality and granularity"
      },
      "branching_strategy": {
        "description": "Is there a defined workflow?",
        "evaluation": "Assess branch naming, merge strategy, release process"
      },
      "ci_cd": {
        "description": "Automation of tests, linting, deployment?",
        "evaluation": "Check pipeline completeness and reliability"
      },
      "dependencies": {
        "description": "Are they up-to-date? Any known vulnerabilities?",
        "evaluation": "Audit dependency versions and security issues"
      }
    },
    "maintainability": {
      "technical_debt": {
        "description": "Are there old TODOs, documented hacks?",
        "evaluation": "Identify and categorize technical debt items"
      },
      "onboarding_time": {
        "description": "Can a new developer contribute quickly?",
        "evaluation": "Assess setup complexity and documentation quality"
      },
      "change_frequency": {
        "description": "Is the code constantly modified due to bugs?",
        "evaluation": "Analyze bug-fix commits vs. feature commits ratio"
      }
    }
  },
  "deliverables": {
    "scoring": "For each factor, provide a score from 1-10 (10 = excellent)",
    "recommendations": "Offer specific, actionable improvements for each evaluated area",
    "priority_matrix": "Rank recommendations by impact vs. effort",
    "risk_assessment": "Highlight critical issues requiring immediate attention"
  },
  "query":"Imagine you are a senior software architect conducting a comprehensive code quality audit. Analyze the provided codebase and deliver a detailed evaluation based on the following quality factors"
}